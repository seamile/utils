#!/usr/bin/env python

import os
from argparse import ArgumentParser
from collections import Counter
from enum import IntEnum

parser = ArgumentParser('fcnt')
parser.add_argument('-a', dest='all', action='store_true',
                    help='all regular and hidden files')

parser.add_argument('-d', dest='dir', action='store_true',
                    help='count the number of directories')

parser.add_argument('-s', dest='size', action='store_true',
                    help='count the size of files')

parser.add_argument('-r', dest='recursive', action='store_true',
                    help='counting recursively')

parser.add_argument(dest='directories', nargs='*', default=['./'])


class Effect(IntEnum):
    default = 0
    bold = 1
    dark = 2
    inverse = 3
    underline = 4
    blink = 5
    hidden = 8


class Color(IntEnum):
    black = 30
    red = 31
    green = 32
    yellow = 33
    blue = 34
    magenta = 35
    cyan = 36
    white = 37
    grey = 90
    bright_red = 91
    bright_green = 92
    bright_yellow = 93
    bright_blue = 94
    bright_magenta = 95
    bright_cyan = 96
    bright_white = 97
    default = 99


def color_print(string,
                color: Color = Color.default,
                effect: Effect = Effect.default):
    '''print the string with color'''
    template = f'\033[{effect};{color}m%s\033[0m'
    print(template % string)


def intuitive_size(size):
    '''TODO: make the size more intuitive'''
    return size


def count_items(directory: str, count_hidden: bool, recursive: bool,
                count_size: bool) -> Counter:
    '''traverse the directory and count'''
    counter = Counter()  # type: ignore

    for root, dirs, files in os.walk(directory):
        if count_hidden:
            counter['files'] += len(files)
            counter['dirs'] += len(dirs)
            if count_size:
                counter['size'] += sum(os.stat(os.path.join(root, f)).st_size
                                       for f in files)
        else:
            counter['files'] += sum(1 for f in files if f[0] != '.')
            counter['dirs'] += sum(1 for d in dirs if d[0] != '.')
            if count_size:
                counter['size'] += sum(os.stat(os.path.join(root, f)).st_size
                                       for f in files if f[0] != '.')
        if not recursive:
            break

    if count_size:
        counter['size'] = intuitive_size(counter['size'])

    return counter


def fit_cn_width(name: str, width: int):
    length = width - len(name.encode('gb18030')) + len(name)
    return name.ljust(length)


def count_column_width(count_result: dict, columns: list):
    '''count the width of each column'''
    width = []
    # dir name width
    names = list(count_result.keys()) + ["Name"]
    width.append(max(len(n.encode('gb18030')) for n in names))

    # columns' width: files, dirs, sizes
    for column in columns:
        max_value = max(cnt[column] for cnt in count_result.values())
        width.append(max(len(str(max_value)), len(column)))
    return width


def main():
    args = parser.parse_args()
    directories = list(filter(os.path.isdir, args.directories))
    result = {}
    for directory in directories:
        result[directory] = count_items(directory, args.all,
                                        args.recursive, args.size)

    if not directories:
        color_print('fcnt: not found any directory.', Color.red)
        exit(3)

    # count column width
    columns = ['files']
    if args.dir:
        columns.append('dirs')
    if args.size:
        columns.append('size')
    width = count_column_width(result, columns)

    # joint the title and print
    title = "name".ljust(width[0] + 1) \
            + ' '.join(s.rjust(w) for s, w in zip(columns, width[1:]))
    color_print(title, Color.yellow)

    # ouput the result
    for directory in directories:
        line = fit_cn_width(directory, width[0] + 1) + \
            ' '.join(str(result[directory][c]).rjust(w)
                     for c, w in zip(columns, width[1:]))
        print(line)


if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        color_print('\rfcnt: user abort.', Color.red)
        exit(1)
    except Exception as e:
        color_print(f'fcnt: {e}.', Color.red)
        exit(2)
