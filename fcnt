#!/usr/bin/env python

import os
from argparse import ArgumentParser
from collections import Counter
from enum import IntEnum
from math import ceil

parser = ArgumentParser('fcnt')
parser.add_argument('-a', dest='all', action='store_true',
                    help='all regular and hidden files')

parser.add_argument('-d', dest='dir', action='store_true',
                    help='count the number of directories')

parser.add_argument('-s', dest='size', action='store_true',
                    help='count the size of files')

parser.add_argument('-r', dest='recursive', action='store_true',
                    help='counting recursively')

parser.add_argument(dest='directories', nargs='*', default=['./'])


class Effect(IntEnum):
    default = 0
    bold = 1
    dark = 2
    inverse = 3
    underline = 4
    blink = 5
    hidden = 8


class Color(IntEnum):
    black = 30
    red = 31
    green = 32
    yellow = 33
    blue = 34
    magenta = 35
    cyan = 36
    white = 37
    grey = 90
    bright_red = 91
    bright_green = 92
    bright_yellow = 93
    bright_blue = 94
    bright_magenta = 95
    bright_cyan = 96
    bright_white = 97
    default = 99


def color_print(string,
                color: Color = Color.default,
                effect: Effect = Effect.default):
    '''print the string with color'''
    template = f'\033[{effect};{color}m%s\033[0m'
    print(template % string)


def get_size(filepath):
    st = os.stat(filepath)
    return ceil(st.st_size / st.st_blksize) * st.st_blksize


def intuitive_size(size):
    '''make the size more intuitive'''
    for unit in ['B', 'K', 'M', 'G', 'T', 'P']:
        if size >= 1024:
            size = size / 1024.0
        else:
            size = round(size, 1)
            break
    return f'{size}{unit}'


def count_items(directory: str, count_hidden: bool, recursive: bool,
                count_size: bool) -> Counter:
    '''traverse the directory and count'''
    counter = Counter()  # type: ignore

    for root, dirs, files in os.walk(directory):
        if count_hidden:
            counter['Files'] += len(files)
            counter['Dirs'] += len(dirs)
            if count_size:
                counter['Size'] += sum(get_size(os.path.join(root, f))
                                       for f in files)
        else:
            counter['Files'] += sum(1 for f in files if f[0] != '.')
            counter['Dirs'] += sum(1 for d in dirs if d[0] != '.')
            if count_size:
                counter['Size'] += sum(get_size(os.path.join(root, f))
                                       for f in files if f[0] != '.')
        if not recursive:
            break

    if count_size:
        counter['Size'] = intuitive_size(counter['Size'])

    return counter


def fit_cn_width(name: str, width: int):
    length = width - len(name.encode('gb18030')) + len(name)
    return name.ljust(length)


def count_column_width(count_result: dict, columns: list):
    '''count the width of each column'''
    width = []
    # dir name width
    names = list(count_result.keys()) + ["Name"]
    width.append(max(len(n.encode('gb18030')) for n in names))

    # columns' width: files, dirs, sizes
    for column in columns:
        max_length = len(column)
        for cnt in count_result.values():
            val = f'{cnt[column]}'
            max_length = max(len(val), max_length)
        width.append(max_length)
    return width


def main():
    args = parser.parse_args()
    directories = list(filter(os.path.isdir, args.directories))
    if not directories:
        color_print('fcnt: not found any directory.', Color.red)
        exit(3)

    # count items
    result = {}
    for directory in directories:
        result[directory] = count_items(directory, args.all,
                                        args.recursive, args.size)

    # count the width of each column
    columns = ['Files']
    if args.dir:
        columns.append('Dirs')
    if args.size:
        columns.append('Size')
    width = count_column_width(result, columns)

    # joint the title and print
    title = "Name".ljust(width[0] + 3) \
            + '   '.join(c.rjust(w) for c, w in zip(columns, width[1:]))
    color_print(title, Color.bright_yellow, Effect.underline)

    # ouput the result
    template = '   '.join(f'%({c}){w}s' for c, w in zip(columns, width[1:]))
    for d in directories:
        line = fit_cn_width(d, width[0] + 3) + template % result[d]
        print(line)


if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        color_print('\rfcnt: user abort.', Color.red)
        exit(1)
    except Exception as e:
        color_print(f'fcnt: {e}.', Color.red)
        exit(2)
