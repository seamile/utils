#!/usr/bin/env python
import os
from argparse import ArgumentParser
from bisect import insort
from collections import defaultdict
from hashlib import md5
from imghdr import what
from pathlib import Path

parser = ArgumentParser('samechk')
parser.add_argument('-t', dest='type', choices=['name', 'hash'], default='name',
                    help='the checking types.')
parser.add_argument('-d', dest='not_recursively', action='store_true',
                    help='directories only be listed one layer (not searched recursively)')
parser.add_argument(dest='targets', nargs='*', default=('./',), help='target files and dirs')
args = parser.parse_args()

hash_map = defaultdict(list)
name_map = defaultdict(list)

IMG_EXT = ['jpeg', 'png', 'bmp', 'webp']
CHECKING_TYPE = args.type


def find_images(path: Path, recursively=True):
    if path.is_dir():
        if recursively:
            for parent, _, files in os.walk(path):
                for fname in files:
                    if not fname.startswith('.'):
                        fpath = Path(parent).joinpath(fname)
                        if fpath.is_file() and what(fpath) in IMG_EXT:
                            yield fpath
        else:
            for _path in path.iterdir():
                if _path.is_file() and what(_path) in IMG_EXT:
                    yield _path
    else:
        if what(path) in ['jpeg', 'png', 'bmp', 'webp']:
            yield path


if __name__ == '__main__':
    recursively = not args.not_recursively
    for target in args.targets:
        _path = Path(target)
        for img in find_images(_path, recursively):
            if CHECKING_TYPE == 'name':
                insort(name_map[img.stem], img.as_posix())
            else:
                h = md5(img.read_bytes()).hexdigest()
                insort(hash_map[h], img.as_posix())

    if CHECKING_TYPE == 'name':
        for v in sorted(name_map.values()):
            if len(v) > 1:
                print(f'{"   ".join(v)}')
    else:
        for v in sorted(hash_map.values()):
            if len(v) > 1:
                print(f'{"   ".join(v)}')
